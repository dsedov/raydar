#usda 1.0
(
    defaultPrim = "geo"
    endTimeCode = 1
    framesPerSecond = 24
    metersPerUnit = 1
    startTimeCode = 1
    timeCodesPerSecond = 24
    upAxis = "Y"
)

def Xform "geo" (
    kind = "group"
)
{
    def Xform "box" (
        prepend apiSchemas = ["MaterialBindingAPI"]
        kind = "component"
    )
    {
        rel material:binding = </materials/quicksurfacematerial1>

        def Mesh "mesh_0"
        {
            float3[] extent = [(-5, 0, -5), (5, 10, 5)]
            int[] faceVertexCounts = [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]
            int[] faceVertexIndices = [0, 1, 5, 4, 1, 2, 6, 5, 2, 3, 7, 6, 4, 5, 9, 8, 5, 6, 10, 9, 6, 7, 11, 10, 8, 9, 13, 12, 9, 10, 14, 13, 10, 11, 15, 14, 16, 17, 21, 20, 17, 18, 22, 21, 18, 19, 23, 22, 20, 21, 25, 24, 21, 22, 26, 25, 22, 23, 27, 26, 24, 25, 29, 28, 25, 26, 30, 29, 26, 27, 31, 30, 32, 33, 37, 36, 33, 34, 38, 37, 34, 35, 39, 38, 36, 37, 41, 40, 37, 38, 42, 41, 38, 39, 43, 42, 40, 41, 45, 44, 41, 42, 46, 45, 42, 43, 47, 46, 48, 49, 53, 52, 49, 50, 54, 53, 50, 51, 55, 54, 52, 53, 57, 56, 53, 54, 58, 57, 54, 55, 59, 58, 56, 57, 61, 60, 57, 58, 62, 61, 58, 59, 63, 62, 64, 65, 69, 68, 65, 66, 70, 69, 66, 67, 71, 70, 68, 69, 73, 72, 69, 70, 74, 73, 70, 71, 75, 74, 72, 73, 77, 76, 73, 74, 78, 77, 74, 75, 79, 78]
            uniform token orientation = "leftHanded"
            point3f[] points = [(-5, 0, -5), (-1.6666667, 0, -5), (1.6666665, 0, -5), (5, 0, -5), (-5, 0, -1.6666667), (-1.6666667, 0, -1.6666667), (1.6666665, 0, -1.6666667), (5, 0, -1.6666667), (-5, 0, 1.6666665), (-1.6666667, 0, 1.6666665), (1.6666665, 0, 1.6666665), (5, 0, 1.6666665), (-5, 0, 5), (-1.6666667, 0, 5), (1.6666665, 0, 5), (5, 0, 5), (-5, 10, -5), (-5, 6.666667, -5), (-5, 3.3333335, -5), (-5, 0, -5), (-5, 10, -1.6666667), (-5, 6.666667, -1.6666667), (-5, 3.3333335, -1.6666667), (-5, 0, -1.6666667), (-5, 10, 1.6666665), (-5, 6.666667, 1.6666665), (-5, 3.3333335, 1.6666665), (-5, 0, 1.6666665), (-5, 10, 5), (-5, 6.666667, 5), (-5, 3.3333335, 5), (-5, 0, 5), (5, 0, -5), (5, 3.3333333, -5), (5, 6.6666665, -5), (5, 10, -5), (5, 0, -1.6666667), (5, 3.3333333, -1.6666667), (5, 6.6666665, -1.6666667), (5, 10, -1.6666667), (5, 0, 1.6666665), (5, 3.3333333, 1.6666665), (5, 6.6666665, 1.6666665), (5, 10, 1.6666665), (5, 0, 5), (5, 3.3333333, 5), (5, 6.6666665, 5), (5, 10, 5), (-5, 10, 5), (-1.6666667, 10, 5), (1.6666665, 10, 5), (5, 10, 5), (-5, 10, 1.6666667), (-1.6666667, 10, 1.6666667), (1.6666665, 10, 1.6666667), (5, 10, 1.6666667), (-5, 10, -1.6666665), (-1.6666667, 10, -1.6666665), (1.6666665, 10, -1.6666665), (5, 10, -1.6666665), (-5, 10, -5), (-1.6666667, 10, -5), (1.6666665, 10, -5), (5, 10, -5), (-5, 10, -5), (-1.6666667, 10, -5), (1.6666665, 10, -5), (5, 10, -5), (-5, 6.666667, -5), (-1.6666667, 6.666667, -5), (1.6666665, 6.666667, -5), (5, 6.666667, -5), (-5, 3.3333335, -5), (-1.6666667, 3.3333335, -5), (1.6666665, 3.3333335, -5), (5, 3.3333335, -5), (-5, 0, -5), (-1.6666667, 0, -5), (1.6666665, 0, -5), (5, 0, -5)] (
                interpolation = "vertex"
            )
            uniform token subdivisionScheme = "none"
        }
    }
}

def Scope "materials"
{
    def Material "quicksurfacematerial1" (
        prepend inherits = </mat>
        instanceable = true
        prepend references = @houdini/usd/materials/quick_materials/quick_materials.usd@</Materials/QuickSurfaceMaterial>
    )
    {
        custom float inputs:base = 1
        custom color3f inputs:base_color = (1, 1, 1)
        custom string inputs:base_color_primvar = "displayColor"
        custom float inputs:bump_scale = 0.025
        custom float inputs:bump_style = 0
        custom float inputs:coat = 0
        custom color3f inputs:coat_color = (1, 1, 1)
        custom float inputs:coat_roughness = 0.1
        custom float inputs:emission = 0
        custom color3f inputs:emission_color = (1, 1, 1)
        custom string inputs:emission_color_primvar = ""
        custom string inputs:filtertype = "linear"
        custom float inputs:metalness = 0
        custom color3f inputs:opacity = (1, 1, 1)
        custom string inputs:opacity_primvar = ""
        custom float inputs:projection = 0
        custom string inputs:roughness_primvar = ""
        custom float inputs:sheen = 0
        custom color3f inputs:sheen_color = (1, 1, 1)
        custom float inputs:sheen_roughness = 0.3
        custom float inputs:specular = 1
        custom float inputs:specular_anisotropy = 0
        custom color3f inputs:specular_color = (1, 1, 1)
        custom float inputs:specular_IOR = 1.5
        custom float inputs:specular_rotation = 0
        custom float inputs:specular_roughness = 0.1521
        custom float inputs:subsurface = 0
        custom color3f inputs:subsurface_color = (1, 1, 1)
        custom string inputs:subsurface_color_primvar = ""
        custom color3f inputs:subsurface_radius = (1, 1, 1)
        custom float inputs:subsurface_scale = 1
        custom float inputs:thin_film_IOR = 1.5
        custom float inputs:thin_film_thickness = 0
        custom string inputs:thin_film_thickness_primvar = ""
        custom int inputs:thin_walled = 0
        custom float inputs:transmission = 0
        custom color3f inputs:transmission_color = (1, 1, 1)
        custom string inputs:transmission_color_primvar = ""
        custom float inputs:transmission_depth = 0
        custom float inputs:transmission_dispersion = 0
        custom int inputs:true_displacements = 0
        custom float2 inputs:uv_offset = (0, 0)
        custom string inputs:uv_primvar = "st"
        custom float2 inputs:uv_scale = (1, 1)
        token outputs:mtlx:displacement.connect = None
    }
}

def Xform "lights"
{
    def RectLight "arealight1" (
        prepend apiSchemas = ["HoudiniViewportLightAPI", "HoudiniViewportGuideAPI", "KarmaLightAPI"]
    )
    {
        float2 houdini:clippingRange = (0.001, 10000)
        bool houdini:inviewermenu = 1
        color3f inputs:color = (1, 1, 1)
        float inputs:diffuse = 1
        bool inputs:enableColorTemperature = 0
        float inputs:exposure = 0
        float inputs:height = 3
        float inputs:intensity = 5
        bool inputs:karma:light:renderlightgeo = 1
        bool inputs:normalize = 0
        float inputs:specular = 1
        asset inputs:texture:file = @@
        float inputs:width = 3
        rel light:filters = None
        matrix4d xformOp:transform = ( (1, 0, 0, 0), (0, 0, -1, 0), (0, 1, 0, 0), (0, 9.9, 0, 1) )
        uniform token[] xformOpOrder = ["xformOp:transform"]
    }
}

def Xform "cameras"
{
    def Camera "camera1" (
        prepend apiSchemas = ["HoudiniViewportGuideAPI", "HoudiniCameraPlateAPI"]
    )
    {
        float2 clippingRange = (1, 1000000)
        float exposure = 0
        float focalLength = 0.2
        float focusDistance = 5
        float fStop = 0
        float horizontalAperture = 0.20955
        float horizontalApertureOffset = 0
        asset houdini:backgroundimage = @@
        asset houdini:foregroundimage = @@
        float houdini:guidescale = 1
        bool houdini:inviewermenu = 1
        token projection = "perspective"
        double shutter:close = 0.25
        double shutter:open = -0.25
        float verticalAperture = 0.11787187
        float verticalApertureOffset = 0
        matrix4d xformOp:transform = ( (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 5, 20, 1) )
        uniform token[] xformOpOrder = ["xformOp:transform"]
    }
}

